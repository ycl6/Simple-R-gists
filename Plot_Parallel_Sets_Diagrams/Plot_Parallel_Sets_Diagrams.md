# Visualise interaction between 2 variables with parallel sets diagrams

I-Hsuan Lin

University of Manchester

January 07, 2022

## 1. Introduction

This notebook shows readers how to use `ggforce` package to create parallel sets diagram to show the interaction between 2 categorical variables.

### About demo datasets

All the datasets are available from CRAN or bioconductor.

1. The `Titanic` dataset (from R) provides information on the fate of passengers on the ocean liner ‘Titanic’.
2. The [fission](https://www.bioconductor.org/packages/release/data/experiment/html/fission.html) dataset provides a `RangedSummarizedExperiment` object of read counts in genes for a time course RNA-Seq experiment of fission yeast (*Schizosaccharomyces pombe*) in response to oxidative stress at 0, 15, 30, 60, 120 and 180 mins.
3. The [TENxPBMCData](https://bioconductor.org/packages/release/data/experiment/html/TENxPBMCData.html) single-cell RNA-seq data for on PBMC cells, generated by 10X Genomics.

## 2. Loading required libraries


```R
suppressMessages({
    library(ggforce)
    library(pals)
    library(tidyverse)

    # To Run fission demo
    library(DESeq2)
    library(fission)

    # To Run PBMC demo
    library(scater)
    library(scran)
    library(bluster)
    library(TENxPBMCData)
})
```

## 3. Set output parameters


```R
# Set width
options(width = 110)

# Set output image size
options(repr.plot.width = 12, repr.plot.height = 4, repr.plot.res = 150)
```

## 4. Load functions

The `plot_parallel` function allows users to create plots easily by providing the membership information. The required arguments to use the function are `lab1` and `lab2` which are the membership information to be displayed. 

Optional settings are:
- `labels`: vector of labels for the 2 categorical variables. Default values are `label1` and `label2`.
- `add_counts`: boolean value showing if total counts of each element is displayed with the labels. Default value is `FALSE` (i.e. not showing counts).
- `add_breakdown`: boolean value showing if detailed breakdown of the counts is displayed with the labels on both sides. Use `"left"`, `"right"`, `"both"` (same as `TRUE`) to control which side to show the breakdown. Default value is `FALSE` (i.e. not showing breakdown).
- `text_size`: variable label size. Default value is 4.
- `xlab_size`: main categorical label size. Default value is 14.
- `base_size`: base font size, given in pts. Default value is 20.
- `color`: color palette of the elements in the parallel sets diagram. Default is to use `ggplot2`'s default color palette.


```R
plot_parallel <- function(lab1, lab2, labels = c("label1", "label2"), add_counts = FALSE, add_breakdown = FALSE, 
                          text_size = 4, xlab_size = 14, base_size = 20, color = NULL) {
    if(length(lab1) == 0 | length(lab2) == 0) {
        return("Empty input.")
    }

    # Encode vectors as factors, or drop unused levels
    if(!is.factor(lab1)) {
        lab1 <- as.factor(lab1)
    } else {
        lab1 <- droplevels(lab1)
    }

    if(!is.factor(lab2)) {
        lab2 <- as.factor(lab2)
    } else {
        lab2 <- droplevels(lab2)
    }
    
    lab1name <- levels(lab1)
    lab2name <- levels(lab2)

    # Calculate and append counts to labels
    if(add_counts == TRUE) {
        lab1name <- data.frame(lab = lab1) %>% dplyr::count(lab) %>% 
            mutate(name = paste0(lab, " (", n, ")")) %>% pull(name)
        lab2name <- data.frame(lab = lab2) %>% dplyr::count(lab) %>% 
            mutate(name = paste0(lab, " (", n, ")")) %>% pull(name)
    }

    # Calculate and append detailed breakdown to labels
    if(add_breakdown == TRUE | add_breakdown %in% c("both","left","right")) {
        tab <- data.frame(table(lab1 = lab1, lab2 = lab2))
        breakdown1 <- group_by(tab, lab1) %>% summarise_all(paste, collapse = ",") %>% pull(Freq)
        breakdown2 <- group_by(tab, lab2) %>% summarise_all(paste, collapse = ",") %>% pull(Freq)

        if(add_breakdown != "right") {
            lab1name <- paste0(lab1name, "\n[", breakdown1, "]")        
        }
        if(add_breakdown != "left") {  
            lab2name <- paste0(lab2name, "\n[", breakdown2, "]")
        }
    }

    levels(lab1) <- lab1name
    levels(lab2) <- lab2name
    
    # Rename labels if duplicate names used in the 2 sets
    if(length(intersect(levels(lab1), levels(lab2))) > 0) {
        levels(lab1) <- paste0("(", labels[1], ") ", levels(lab1))
        levels(lab2) <- paste0("(", labels[2], ") ", levels(lab2))
    }
    
    # Build data.frame
    data <- data.frame(lab1 = lab1, lab2 = lab2) %>%
    group_by(lab1, lab2) %>% tally() %>% ungroup() %>% drop_na() %>% gather_set_data(1:2) %>% 
    mutate(x = factor(x, levels = c("lab1", "lab2"))) %>% mutate(y = fct_drop(y))

    data_labels <- tibble(group = unique(data[,c("x", "y")])$x) %>%
    mutate(hjust = ifelse(group == "lab2", 0, 1),
           nudge_x = ifelse(group == "lab2", 0.1, -0.1))
    
    # Build ggplot object
    p <- ggplot(data, aes(x, id = id, split = y, value = n)) +
    geom_parallel_sets(aes(fill = lab1), alpha = 0.6, axis.width = 0.15) + # edge
    geom_parallel_sets_axes(aes(fill = y), size = 0.3, axis.width = 0.1) + # annotation
    geom_text(aes(y = n, split = y), stat = "parallel_sets_axes",
              hjust = data_labels$hjust, nudge_x = data_labels$nudge_x,
              fontface = "bold", color = "black", size = text_size) +
    scale_x_discrete(labels = labels) + theme_void(base_size = base_size) +
    theme(legend.position = "none", plot.margin = unit(c(1, 1, 1, 1), "lines"),
          axis.text.x = element_text(face = "bold", color = "black", size = xlab_size))

    if(!is.null(color)) {
        num <- length(levels(data$y))
        if(length(color) >= num) {
            color <- color[1:num]
            p <- p + scale_fill_manual(values = setNames(color, levels(data$y)))
        } else {
            print("Insufficient colours provided. Revert to default palette.")
        }
    }
    
    return(p)
}
```

## 5. Create plots

### Use `Titanic` dataset


```R
dat <- reshape2::melt(Titanic)
str(dat)
```


```R
table(dat$Class, dat$Age)
```


```R
# Show class and age relationships of the passengers
plot_parallel(dat$Class, dat$Age, labels = c("Class", "Age"))
```


```R
# Show class and age relationships of the passengers,
# change colour and add number of passengers in each classification
plot_parallel(dat$Class, dat$Age, labels = c("Class", "Age"), color = cols25(), add_counts = TRUE)
```


```R
# Show class and age relationships of the passengers,
# change colour and add breakdown of the number of passengers in each classification
plot_parallel(dat$Class, dat$Age, labels = c("Class", "Age"), color = cols25(), add_breakdown = TRUE)
```


```R
# Show class and age relationships of the passengers,
# change colour and add total and breakdown of the number of passengers in each classification
plot_parallel(dat$Class, dat$Age, labels = c("Class", "Age"), color = cols25(), add_counts = TRUE, add_breakdown = TRUE)
```

### Use `fission` dataset


```R
#--- data-loading ---#
data("fission")
fission
str(data.frame(colData(fission)))
```


```R
#--- subset to 2 time points ---#
sel <- colData(fission)$minute %in% c(60,180)
DF <- droplevels(colData(fission)[sel,])
counts <- assay(fission)[,sel]
counts <- counts[rowMeans(counts) > 5,]
```


```R
#--- construct DESeqDataSet ---#
dds<- DESeqDataSetFromMatrix(counts, DF, ~ strain * minute)
dds
```


```R
#--- run DESeq ---#
dds <- DESeq(dds)
data.frame(coef = resultsNames(dds))
```


```R
#--- test strain (genotype) effect ---#
res_strain <- results(dds, name = "strain_mut_vs_wt")
head(res_strain[order(res_strain$pvalue),])
```


```R
#--- test time effect ---#
res_time <- results(dds, name = "minute_180_vs_60")
head(res_time[order(res_time$pvalue),])
```


```R
#--- set alpha at 0.1 ---#
sig_strain <- res_strain$padj < 0.1
sig_strain <- as.factor(as.character(sig_strain))
levels(sig_strain) <- c("Not Significant", "Significant")
table(sig_strain)

sig_time <- res_time$padj < 0.1
sig_time <- as.factor(as.character(sig_time))
levels(sig_time) <- c("Not Significant", "Significant")
table(sig_time)
```


```R
table(sig_strain, sig_time)
```


```R
# Show relationships of the genes that have a significant strain and time effects
plot_parallel(sig_strain, sig_time, labels = c("Strain", "Time"))
```


```R
plot_parallel(sig_strain, sig_time, labels = c("Strain", "Time"), color = pals::cols25())
```


```R
# Show relationships of the genes that have a significant strain and time effects,
# change colour and add number of genes in each classification
plot_parallel(sig_strain, sig_time, labels = c("Strain", "Time"), color = pals::cols25(), add_counts = TRUE)
```


```R
# Show relationships of the genes that have a significant strain and time effects,
# change colour and add breakdown of the genes in each classification
plot_parallel(sig_strain, sig_time, labels = c("Strain", "Time"), color = pals::cols25(), add_breakdown = "both")
```


```R
# Show relationships of the genes that have a significant strain and time effects,
# change colour and add total and breakdown of the genes in each classification
plot_parallel(sig_strain, sig_time, labels = c("Strain", "Time"), color = pals::cols25(), add_counts = TRUE, add_breakdown = "both")
```

### Use `TENxPBMCData` dataset


```R
#--- data-loading ---#
sce.pbmc <- TENxPBMCData("pbmc4k")
sce.pbmc
```


```R
#--- gene-annotation ---#
rownames(sce.pbmc) <- uniquifyFeatureNames(rowData(sce.pbmc)$ENSEMBL_ID, rowData(sce.pbmc)$Symbol)
is.mito <- grep("^MT-", rowData(sce.pbmc)$Symbol_TENx)
```


```R
#--- quality-control ---#
stats <- perCellQCMetrics(sce.pbmc, subsets = list(Mito = is.mito))
high.mito <- isOutlier(stats$subsets_Mito_percent, type = "higher")
sce.pbmc <- sce.pbmc[,!high.mito]
```


```R
#--- normalization ---#
set.seed(10001)
clusters <- quickCluster(sce.pbmc)
sce.pbmc <- computeSumFactors(sce.pbmc, cluster = clusters)
sce.pbmc <- logNormCounts(sce.pbmc)
```


```R
#--- variance-modelling ---#
set.seed(10001)
dec.pbmc <- modelGeneVarByPoisson(sce.pbmc)
top.pbmc <- getTopHVGs(dec.pbmc, prop = 0.1)
```


```R
#--- dimensionality-reduction ---#
set.seed(10001)
sce.pbmc <- denoisePCA(sce.pbmc, subset.row = top.pbmc, technical = dec.pbmc)

set.seed(10001)
sce.pbmc <- runTSNE(sce.pbmc, dimred = "PCA")

set.seed(10001)
sce.pbmc <- runUMAP(sce.pbmc, dimred = "PCA")

sce.pbmc
```


```R
#--- walktrap clustering ---#
clu.walktrap <- clusterCells(sce.pbmc, use.dimred = "PCA", BLUSPARAM = NNGraphParam(cluster.fun = "walktrap"))
table(clu.walktrap)
```


```R
#--- louvain clustering ---#
clu.louvain <- clusterCells(sce.pbmc, use.dimred = "PCA", BLUSPARAM = NNGraphParam(cluster.fun = "louvain"))
table(clu.louvain)
```


```R
table(clu.walktrap, clu.louvain)
```


```R
# Increase plot height
options(repr.plot.height = 7)
```


```R
# Show relationships of 2 different cluster assignments of cells
plot_parallel(clu.walktrap, clu.louvain, labels = c("walktrap", "louvain"))
```


```R
# Show relationships of 2 different cluster assignments of cells,
# change colour and add number of cells in each classification
plot_parallel(clu.walktrap, clu.louvain, labels = c("walktrap", "louvain"), color = glasbey(), add_counts = TRUE)
```


```R
# Increase plot height
options(repr.plot.height = 12)
```


```R
# Show relationships of 2 different cluster assignments of cells,
# change colour and add breakdown of the cells in "walktrap" classification
plot_parallel(clu.walktrap, clu.louvain, labels = c("walktrap", "louvain"), color = glasbey(), add_breakdown = "left")
```


```R
# Show relationships of 2 different cluster assignments of cells,
# change colour and add breakdown of the cells in "louvain" classification
plot_parallel(clu.walktrap, clu.louvain, labels = c("walktrap", "louvain"), color = glasbey(), add_breakdown = "right")
```

## Session info


```R
sessionInfo()
```
